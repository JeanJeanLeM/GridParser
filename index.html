<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4×4 Grid Image Splitter</title>
  <link rel="stylesheet" href="css/shared.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/5.1.0/tesseract.min.js"></script>
  <script src="js/gridSplit.js"></script>
  <script src="js/gridDetect.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: var(--font-sans);
      margin: 0;
      min-height: 100vh;
      background: var(--page-bg);
    }
    .hero {
      text-align: center;
      margin-bottom: var(--section-gap);
    }
    .hero__label {
      font-size: var(--text-xs);
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
      margin: 0 0 0.35rem 0;
    }
    .hero h1 {
      font-family: var(--font-serif);
      font-size: var(--heading-lg);
      font-weight: 700;
      margin: 0 0 0.75rem 0;
      color: var(--text-primary);
    }
    .intro {
      font-size: var(--text-base);
      color: var(--text-muted);
      line-height: 1.5;
      margin: 0;
      max-width: 42rem;
      margin-left: auto;
      margin-right: auto;
    }
    .drop-section,
    .grid-editor,
    .output {
      background: var(--card-bg);
      border-radius: var(--radius-card);
      padding: var(--card-padding);
      margin-bottom: var(--section-gap);
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .drop-zone {
      display: block;
      border: 2px dashed var(--border-input);
      border-radius: 8px;
      padding: 2.5rem 2rem;
      text-align: center;
      cursor: pointer;
      background: var(--input-bg);
      transition: background 0.15s, border-color 0.15s;
      position: relative;
    }
    .drop-zone:hover, .drop-zone.dragover {
      background: #eee;
      border-color: var(--text-muted);
    }
    .drop-zone.dragover {
      border-color: var(--text-secondary);
      background: #e8e8e8;
    }
    .drop-zone p { margin: 0; color: var(--text-muted); }
    .drop-zone .drop-title { font-weight: 600; color: var(--text-secondary); margin-bottom: 0.25rem; }
    .drop-zone .drop-hint { font-size: var(--text-sm); color: var(--text-subtle); margin-bottom: 0.5rem; }
    .drop-zone .format-hint {
      font-size: var(--text-xs);
      color: var(--border-input);
      margin-top: 0.5rem;
    }
    .browse-btn {
      display: inline-block;
      margin-top: 0.75rem;
      padding: 0.5rem 1rem;
      font-size: var(--text-sm);
      color: var(--text-secondary);
      background: var(--card-bg);
      border: 1px solid var(--border-input);
      border-radius: var(--radius-input);
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }
    .browse-btn:hover {
      background: #e8e8e8;
      border-color: var(--text-muted);
    }
    #file-input { display: none; }
    .trim-row { margin-top: 1rem; font-size: var(--text-sm); display: flex; flex-wrap: wrap; align-items: baseline; gap: 0.5rem 0.75rem; }
    .trim-row label { margin-right: 0; }
    .trim-row .trim-input { width: 4em; padding: 0.25rem 0.35rem; border: 1px solid var(--border-input); border-radius: var(--radius-input); font-size: var(--text-sm); }
    .trim-hint { color: var(--border-input); font-size: var(--text-xs); }
    .trim-hint-block { display: block; width: 100%; margin-top: 0.25rem; }
    .download-hint { font-size: var(--text-xs); color: var(--text-subtle); margin-top: 0.5rem; margin-bottom: 0; }
    .error { color: var(--error); margin-top: 0.5rem; font-size: var(--text-sm); }
    .output {
      margin-top: 0;
      display: none;
    }
    .output.visible { display: block; }
    .output .section-title-row { margin-bottom: 0.25rem; }
    .output .section-title-row + .output-hint { margin-bottom: 0.5rem; }
    .output-hint { font-size: var(--text-xs); color: var(--text-hint); margin: 0 0 0.5rem 0; }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 1rem;
      max-width: 100%;
      align-items: start;
    }
    .preview-tile {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      align-items: stretch;
    }
    .preview-tile .tile-img-wrap {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      background: var(--input-bg);
      border-radius: 4px;
      overflow: hidden;
    }
    .preview-tile .tile-img-wrap img {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      object-position: center;
    }
    .preview-tile .tile-name {
      width: 100%;
      box-sizing: border-box;
      padding: 0.4rem 0.5rem;
      font-size: var(--text-xs);
      border: 1px solid var(--border);
      border-radius: 4px;
      text-align: center;
      min-height: 2.25rem;
    }
    .preview-tile .tile-name:focus {
      border-color: var(--text-secondary);
      outline: none;
      box-shadow: 0 0 0 2px rgba(229, 161, 82, 0.25);
    }
    .btn {
      display: inline-block;
      padding: var(--btn-padding);
      background: var(--btn-primary-bg);
      color: #fff;
      border: none;
      border-radius: var(--radius-input);
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.15s;
    }
    .btn:hover { background: var(--btn-primary-hover); }
    .btn:focus { outline: 2px solid var(--focus-ring); outline-offset: 2px; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .grid-editor {
      display: none;
      margin-top: 0;
    }
    .grid-editor.visible { display: block; }
    .grid-editor .section-title-row { margin-bottom: 0.5rem; }
    .grid-editor .grid-editor-intro { margin-bottom: 0.75rem; font-size: var(--text-sm); color: var(--text-muted); }
    .grid-editor-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem 1.5rem;
      margin-bottom: 1rem;
      font-size: var(--text-xs);
      color: var(--text-hint);
    }
    .grid-editor-legend span { display: inline-flex; align-items: center; gap: 0.35rem; }
    .grid-editor-legend .legend-dot { width: 12px; height: 12px; border-radius: 2px; flex-shrink: 0; }
    .legend-dot--blue { background: rgba(50, 100, 220, 0.95); }
    .legend-dot--red { background: rgba(220, 50, 50, 0.9); }
    .grid-editor-toolbar {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    .grid-editor-toolbar__row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
    }
    .grid-editor-toolbar__row--controls label { font-size: 0.9rem; }
    .grid-editor-toolbar__row--controls input[type="range"] { vertical-align: middle; }

    /* Grid format picker: visual 4×4 selector */
    .grid-format-picker {
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.5rem 0.75rem;
      background: linear-gradient(180deg, #fff 0%, var(--input-bg) 100%);
      border: 1px solid var(--border-light);
      border-radius: var(--radius-card);
      margin-right: 0.25rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    .grid-format-picker:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(229, 161, 82, 0.25);
    }
    .grid-format-picker__label {
      font-size: var(--text-xs);
      font-weight: 600;
      color: var(--text-muted);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .grid-format-picker__grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 2px;
      width: 56px;
      height: 56px;
      border-radius: 6px;
      padding: 0;
    }
    .grid-format-picker__cell {
      border-radius: 3px;
      cursor: pointer;
      transition: background 0.15s, transform 0.1s;
      background: var(--card-bg);
      border: 1px solid rgba(0,0,0,0.06);
    }
    .grid-format-picker__cell:hover {
      background: #f0ebe4;
      transform: scale(1.06);
    }
    .grid-format-picker__cell.in-selection {
      background: var(--accent);
      border-color: rgba(0,0,0,0.1);
      box-shadow: 0 1px 2px rgba(0,0,0,0.08);
    }
    .grid-format-picker__cell.in-selection:hover {
      background: #e09a38;
      filter: brightness(1.08);
    }
    .grid-format-picker__cell.out-of-preview {
      opacity: 0.35;
      background: var(--card-bg);
    }
    .grid-format-picker__cell:focus {
      outline: none;
    }
    .grid-format-picker__cell:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
    }
    .grid-format-picker__value {
      font-family: var(--font-serif);
      font-size: 1.05rem;
      font-weight: 700;
      color: var(--text-primary);
      min-width: 2.4em;
      letter-spacing: 0.02em;
    }
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .loupe-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      padding: 0;
      border: 1px solid var(--border);
      border-radius: var(--radius-input);
      background: var(--card-bg);
      cursor: pointer;
      color: var(--text-muted);
    }
    .loupe-btn:hover { background: #f0f0f0; color: var(--text-secondary); }
    .loupe-btn.active { background: #e0e8f0; border-color: var(--text-secondary); color: var(--text-primary); }
    .loupe-btn svg { width: 20px; height: 20px; }
    .loupe-container {
      position: fixed;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid #333;
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
      pointer-events: none;
      z-index: 1000;
      display: none;
    }
    .loupe-container.visible { display: block; }
    .loupe-container canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .grid-preview-scroll {
      overflow: auto;
      max-height: 70vh;
      margin-bottom: 1rem;
      border: 1px solid var(--border-light);
      border-radius: 8px;
      background: var(--input-bg);
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .grid-preview-wrapper {
      position: relative;
      display: block;
      transform-origin: center top;
      flex-shrink: 0;
    }
    .grid-overlay {
      position: absolute;
      left: 0;
      top: 0;
      cursor: crosshair;
      pointer-events: auto;
    }
    .grid-editor-buttons { margin-top: 1rem; }
    .grid-editor-labelisation { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; }
    .grid-editor-actions {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      border-top: 1px solid var(--border-light);
    }
    .grid-editor-actions .btn { margin-right: 0; }
    .trim-inline { display: inline-flex; align-items: center; gap: 0.35rem; font-size: 0.9rem; }
    .trim-inline input { padding: 0.25rem 0.35rem; border: 1px solid var(--border-input); border-radius: var(--radius-input); font-size: var(--text-sm); }
    .trim-inline input:focus { outline: none; border-color: var(--text-secondary); box-shadow: 0 0 0 2px rgba(229, 161, 82, 0.2); }
    input[type="range"]:focus { outline: none; }
    input[type="range"]:focus-visible { box-shadow: 0 0 0 2px var(--focus-ring); }
    .auto-name-label { display: inline-flex; align-items: center; gap: 0.35rem; font-size: 0.9rem; cursor: pointer; }
    .detecting-labels { font-size: var(--text-sm); color: var(--text-hint); margin: 0.25rem 0 0.5rem 0; }
    .btn-secondary {
      background: #666;
      color: #fff;
    }
    .btn-secondary:hover { background: var(--btn-primary-hover); }
  </style>
</head>
<body>
  <header class="app-header">
    <div class="app-header__inner">
      <a href="index.html" class="app-header__logo">Grid<span class="app-header__logo-num">2</span>Icons</a>
      <a href="prompt-builder.html" class="app-header__nav">PROMPT BUILDER →</a>
      <a href="premium.html" class="app-header__nav">Premium</a>
      <div class="app-header__auth">
        <span id="auth-loading" class="auth-loading">Loading…</span>
        <span id="auth-guest" class="auth-guest" style="display:none;">
          <button type="button" id="auth-btn-login" class="app-header__auth-btn">Sign in</button>
          <span class="app-header__auth-sep" aria-hidden="true">|</span>
          <button type="button" id="auth-btn-signup" class="app-header__auth-btn">Sign up</button>
        </span>
        <div id="auth-user" class="profile-dropdown" style="display:none;">
          <button type="button" id="auth-profile-trigger" class="app-header__auth-btn profile-dropdown__trigger" aria-expanded="false" aria-haspopup="true" aria-controls="auth-profile-menu">
            Signed in as <span id="auth-user-email"></span> <span class="profile-dropdown__chevron" aria-hidden="true">▼</span>
          </button>
          <div id="auth-profile-menu" class="profile-dropdown__menu" role="menu" aria-label="Account menu" hidden>
            <div class="profile-dropdown__email" id="auth-profile-email"></div>
            <a href="premium.html" class="profile-dropdown__link" role="menuitem">Premium</a>
            <button type="button" id="auth-btn-logout" class="profile-dropdown__btn" role="menuitem">Disconnect</button>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="main-content">
    <div class="hero">
      <p class="hero__label" aria-hidden="true">IMAGE UTILITY</p>
      <h1>Grid Image Splitter</h1>
      <p class="intro">Upload a single 4×4 grid image (e.g. from ChatGPT). Split it into 16 clean tiles — no borders — then download as a ZIP.</p>
    </div>

  <section class="drop-section" aria-labelledby="step1-title">
    <div class="section-title-row">
      <span class="step-badge" aria-hidden="true">1</span>
      <h2 id="step1-title" class="section-title">Upload your grid image</h2>
    </div>
    <div class="drop-zone" id="drop-zone">
      <p class="drop-title">Drop your 4×4 grid image here</p>
      <p class="drop-hint">or click to browse your files</p>
      <button type="button" class="browse-btn" id="browse-btn">Browse files…</button>
      <p class="format-hint">Supports PNG, JPG, WebP.</p>
    </div>
    <input type="file" id="file-input" accept="image/png,image/jpeg,image/jpg,image/webp" aria-label="Choose 4×4 grid image">
  </section>
  <p class="error" id="error" aria-live="polite"></p>

  <section class="grid-editor" id="grid-editor" aria-labelledby="step2-title">
    <div class="section-title-row">
      <span class="step-badge" aria-hidden="true">2</span>
      <h2 id="step2-title" class="section-title">Adjust cutting lines</h2>
    </div>
    <p class="grid-editor-intro">Grid and outer borders are auto-detected on upload. Drag <strong style="color: rgba(50,100,220,0.95);">blue</strong> (outer) and <strong style="color: rgba(220,50,50,0.9);">red</strong> (inner) lines to set where tiles are cut. These lines are guides only—they are not drawn on your image and do not appear in the downloaded tiles.</p>
    <div class="grid-editor-legend">
      <span><span class="legend-dot legend-dot--blue" aria-hidden="true"></span> Outer border lines</span>
      <span><span class="legend-dot legend-dot--red" aria-hidden="true"></span> Inner cutting lines (where each tile is split)</span>
    </div>
    <div class="grid-editor-toolbar">
      <div class="grid-editor-toolbar__row grid-editor-toolbar__row--grid">
        <div class="grid-format-picker" role="group" aria-labelledby="grid-format-picker-label">
          <span class="grid-format-picker__label" id="grid-format-picker-label">Grid</span>
          <div class="grid-format-picker__grid" id="grid-format-visual" aria-hidden="true">
            <!-- 4×4 cells: row 0..3, col 0..3. Cell (r,c) = format (r+1)×(c+1). Filled by JS. -->
          </div>
          <span class="grid-format-picker__value" id="grid-format-value" aria-live="polite">4×4</span>
          <select id="grid-format" aria-label="Grid format (rows × columns)" class="visually-hidden">
            <option value="1_1">1×1</option>
            <option value="1_2">1×2</option>
            <option value="2_1">2×1</option>
            <option value="2_2">2×2</option>
            <option value="1_3">1×3</option>
            <option value="3_1">3×1</option>
            <option value="2_3">2×3</option>
            <option value="3_2">3×2</option>
            <option value="1_4">1×4</option>
            <option value="4_1">4×1</option>
            <option value="2_4">2×4</option>
            <option value="4_2">4×2</option>
            <option value="3_3">3×3</option>
            <option value="3_4">3×4</option>
            <option value="4_3">4×3</option>
            <option value="4_4" selected>4×4</option>
          </select>
        </div>
      </div>
      <div class="grid-editor-toolbar__row grid-editor-toolbar__row--controls">
        <label>Zoom: <span id="zoom-value">1</span>×</label>
        <input type="range" id="zoom" min="0.5" max="2.5" step="0.1" value="1" aria-label="Zoom">
        <label>Line thickness: <span id="line-thickness-value">4</span>px</label>
        <input type="range" id="line-thickness" min="0" max="20" step="1" value="4" aria-label="Cutting line thickness">
        <button type="button" class="loupe-btn" id="loupe-btn" title="Toggle 4× loupe (follows cursor)" aria-pressed="false">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
        </button>
      </div>
    </div>
    <div class="grid-preview-scroll" id="grid-preview-scroll">
      <div class="grid-preview-wrapper" id="grid-preview-wrapper">
        <img id="grid-image" alt="Your grid image">
        <canvas id="grid-overlay" class="grid-overlay" aria-hidden="true"></canvas>
      </div>
    </div>
    <div class="grid-editor-buttons">
      <div class="grid-editor-labelisation">
        <span class="trim-inline">
          <label for="trim-pixels-inline">Trim:</label>
          <input type="number" id="trim-pixels-inline" min="0" max="20" value="4" step="1" style="width: 3.5em;" title="Pixels to remove from each side of every tile">
        </span>
        <span class="trim-inline">
          <label for="label-region-pct">Label region %:</label>
          <input type="number" id="label-region-pct" min="10" max="50" value="30" step="5" style="width: 3.5em;" title="Bottom % of tile used for label detection">
        </span>
        <label class="auto-name-label">
          Auto-name
          <input type="checkbox" id="auto-name-from-labels" checked>
        </label>
      </div>
      <div class="grid-editor-actions">
        <button type="button" class="btn btn-secondary" id="auto-detect-btn">Auto-detect grid</button>
        <button type="button" class="btn btn-secondary" id="reset-lines">Reset lines</button>
        <button type="button" class="btn btn-primary" id="cut-btn">Cut and create images</button>
      </div>
    </div>
  </section>

  <div class="loupe-container" id="loupe-container" aria-hidden="true">
    <canvas id="loupe-canvas" width="120" height="120"></canvas>
  </div>

  <section class="output" id="output" aria-labelledby="step3-title">
    <div class="section-title-row">
      <span class="step-badge" aria-hidden="true">3</span>
      <h2 id="step3-title" class="section-title">Preview &amp; download tiles</h2>
    </div>
    <p class="output-hint">Rename each file if you like, then download them all as a single ZIP.</p>
    <p class="detecting-labels" id="detecting-labels" aria-live="polite" style="display: none;">Detecting labels…</p>
    <div class="preview-grid" id="preview-grid"></div>
    <button type="button" class="btn btn-primary" id="download-zip">Download all as ZIP</button>
    <p class="download-hint">If Windows blocks the file, right-click it → Properties → Unblock → OK. Downloaded tiles contain only your image—no overlay or guide lines.</p>
  </section>

  </main>

  <script>
    (function () {
      var dropZone = document.getElementById('drop-zone');
      var fileInput = document.getElementById('file-input');
      var errorEl = document.getElementById('error');
      var outputEl = document.getElementById('output');
      var previewGrid = document.getElementById('preview-grid');
      var downloadBtn = document.getElementById('download-zip');

      var tileBlobs = [];
      var objectUrl = null;
      var currentImage = null;
      var xBounds = [];
      var yBounds = [];
      var drag = { active: false, axis: null, index: null };
      var gridImg = document.getElementById('grid-image');
      var gridOverlay = document.getElementById('grid-overlay');
      var gridWrapper = document.getElementById('grid-preview-wrapper');
      var gridScroll = document.getElementById('grid-preview-scroll');
      var gridEditor = document.getElementById('grid-editor');
      var baseWidth = 0;
      var baseHeight = 0;
      var loupeOn = false;
      var loupeContainer = document.getElementById('loupe-container');
      var loupeCanvas = document.getElementById('loupe-canvas');
      var LOUPE_SIZE = 120;
      var LOUPE_ZOOM = 4;
      var MARGIN = 10;

      function getTrimPixels() {
        var el = document.getElementById('trim-pixels-inline') || document.getElementById('trim-pixels');
        return el ? Math.max(0, parseInt(el.value, 10) || 0) : 0;
      }
      function getLabelRegionPct() {
        var el = document.getElementById('label-region-pct');
        var n = el ? parseInt(el.value, 10) : 30;
        return Math.max(10, Math.min(50, isNaN(n) ? 30 : n));
      }
      function getZoom() {
        var el = document.getElementById('zoom');
        return el ? parseFloat(el.value) || 1 : 1;
      }
      function getLineThickness() {
        var el = document.getElementById('line-thickness');
        return el ? Math.max(0, parseInt(el.value, 10) || 0) : 0;
      }
      function getGridFormat() {
        var sel = document.getElementById('grid-format');
        if (!sel || !sel.value) return { rows: 4, cols: 4 };
        var parts = sel.value.split('_');
        var rows = Math.max(1, Math.min(4, parseInt(parts[0], 10) || 4));
        var cols = Math.max(1, Math.min(4, parseInt(parts[1], 10) || 4));
        return { rows: rows, cols: cols };
      }

      function clearError() {
        errorEl.textContent = '';
      }
      function showError(msg) {
        errorEl.textContent = msg;
      }

      function initBounds(w, h) {
        var fmt = getGridFormat();
        var cols = fmt.cols;
        var rows = fmt.rows;
        xBounds = [];
        for (var c = 0; c <= cols; c++) xBounds.push((c * w) / cols);
        yBounds = [];
        for (var r = 0; r <= rows; r++) yBounds.push((r * h) / rows);
      }

      function updateLoupe(clientX, clientY) {
        if (!loupeOn || !loupeContainer || !loupeCanvas || !currentImage) return;
        var rect = gridOverlay.getBoundingClientRect();
        if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
          loupeContainer.classList.remove('visible');
          return;
        }
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var imgX = (clientX - rect.left - MARGIN) / (baseWidth || 1) * w;
        var imgY = (clientY - rect.top - MARGIN) / (baseHeight || 1) * h;
        var halfRegion = (LOUPE_SIZE / LOUPE_ZOOM) / 2;
        var sx = Math.max(0, imgX - halfRegion);
        var sy = Math.max(0, imgY - halfRegion);
        var sw = Math.min(w - sx, halfRegion * 2);
        var sh = Math.min(h - sy, halfRegion * 2);
        if (sw <= 0 || sh <= 0) return;
        loupeContainer.style.left = (clientX - LOUPE_SIZE / 2) + 'px';
        loupeContainer.style.top = (clientY - LOUPE_SIZE / 2) + 'px';
        var ctx = loupeCanvas.getContext('2d');
        ctx.save();
        ctx.beginPath();
        ctx.arc(LOUPE_SIZE / 2, LOUPE_SIZE / 2, LOUPE_SIZE / 2, 0, 2 * Math.PI);
        ctx.clip();
        ctx.drawImage(currentImage, sx, sy, sw, sh, 0, 0, LOUPE_SIZE, LOUPE_SIZE);
        function toLoupeX(px) { return ((px - sx) / sw) * LOUPE_SIZE; }
        function toLoupeY(py) { return ((py - sy) / sh) * LOUPE_SIZE; }
        var lw = Math.max(1.5, 2);
        var lastX = xBounds.length - 1;
        var lastY = yBounds.length - 1;
        ctx.strokeStyle = 'rgba(50, 100, 220, 0.95)';
        ctx.lineWidth = lw;
        ctx.beginPath();
        ctx.moveTo(toLoupeX(xBounds[0]), 0);
        ctx.lineTo(toLoupeX(xBounds[0]), LOUPE_SIZE);
        ctx.moveTo(toLoupeX(xBounds[lastX]), 0);
        ctx.lineTo(toLoupeX(xBounds[lastX]), LOUPE_SIZE);
        ctx.moveTo(0, toLoupeY(yBounds[0]));
        ctx.lineTo(LOUPE_SIZE, toLoupeY(yBounds[0]));
        ctx.moveTo(0, toLoupeY(yBounds[lastY]));
        ctx.lineTo(LOUPE_SIZE, toLoupeY(yBounds[lastY]));
        ctx.stroke();
        ctx.strokeStyle = 'rgba(220, 50, 50, 0.9)';
        ctx.lineWidth = lw;
        ctx.beginPath();
        for (var i = 1; i < lastX; i++) {
          var lx = toLoupeX(xBounds[i]);
          if (lx >= -1 && lx <= LOUPE_SIZE + 1) {
            ctx.moveTo(lx, 0);
            ctx.lineTo(lx, LOUPE_SIZE);
          }
        }
        for (var j = 1; j < lastY; j++) {
          var ly = toLoupeY(yBounds[j]);
          if (ly >= -1 && ly <= LOUPE_SIZE + 1) {
            ctx.moveTo(0, ly);
            ctx.lineTo(LOUPE_SIZE, ly);
          }
        }
        ctx.stroke();
        ctx.restore();
        loupeContainer.classList.add('visible');
      }

      function drawOverlay() {
        if (!currentImage || !gridOverlay) return;
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var cw = gridOverlay.width;
        var ch = gridOverlay.height;
        if (cw <= 0 || ch <= 0) return;
        var ctx = gridOverlay.getContext('2d');
        ctx.clearRect(0, 0, cw, ch);
        var thickness = Math.max(1, getLineThickness());
        function dispX(px) { return MARGIN + (px / w) * baseWidth; }
        function dispY(py) { return MARGIN + (py / h) * baseHeight; }
        var lastX = xBounds.length - 1;
        var lastY = yBounds.length - 1;
        // Outer cut lines (blue)
        ctx.strokeStyle = 'rgba(50, 100, 220, 0.95)';
        ctx.lineWidth = Math.max(2, thickness);
        ctx.beginPath();
        ctx.moveTo(dispX(xBounds[0]), 0);
        ctx.lineTo(dispX(xBounds[0]), ch);
        ctx.moveTo(dispX(xBounds[lastX]), 0);
        ctx.lineTo(dispX(xBounds[lastX]), ch);
        ctx.moveTo(0, dispY(yBounds[0]));
        ctx.lineTo(cw, dispY(yBounds[0]));
        ctx.moveTo(0, dispY(yBounds[lastY]));
        ctx.lineTo(cw, dispY(yBounds[lastY]));
        ctx.stroke();
        // Inner grid lines (red)
        ctx.strokeStyle = 'rgba(220, 50, 50, 0.9)';
        ctx.lineWidth = thickness;
        ctx.beginPath();
        for (var i = 1; i < lastX; i++) {
          ctx.moveTo(dispX(xBounds[i]), 0);
          ctx.lineTo(dispX(xBounds[i]), ch);
        }
        for (var j = 1; j < lastY; j++) {
          ctx.moveTo(0, dispY(yBounds[j]));
          ctx.lineTo(cw, dispY(yBounds[j]));
        }
        ctx.stroke();
      }

      function hitLine(imgX, imgY) {
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var hitPx = Math.max(8, w / 80);
        for (var i = 0; i < xBounds.length; i++) {
          if (Math.abs(imgX - xBounds[i]) <= hitPx) return { axis: 'v', index: i };
        }
        for (var j = 0; j < yBounds.length; j++) {
          if (Math.abs(imgY - yBounds[j]) <= hitPx) return { axis: 'h', index: j };
        }
        return null;
      }

      function setupGridEditor(img) {
        currentImage = img;
        var w = img.naturalWidth;
        var h = img.naturalHeight;
        initBounds(w, h);
        gridImg.src = img.src;
        function sizeOverlay() {
          var w = currentImage.naturalWidth;
          var h = currentImage.naturalHeight;
          var maxDisplay = 560;
          if (w >= h) {
            baseWidth = Math.min(w, maxDisplay);
            baseHeight = Math.round((h / w) * baseWidth);
          } else {
            baseHeight = Math.min(h, maxDisplay);
            baseWidth = Math.round((w / h) * baseHeight);
          }
          if (!baseWidth || !baseHeight) return;
          var totalW = baseWidth + 2 * MARGIN;
          var totalH = baseHeight + 2 * MARGIN;
          gridImg.style.position = 'absolute';
          gridImg.style.left = MARGIN + 'px';
          gridImg.style.top = MARGIN + 'px';
          gridImg.style.width = baseWidth + 'px';
          gridImg.style.height = baseHeight + 'px';
          gridImg.style.maxWidth = 'none';
          gridOverlay.style.left = '0';
          gridOverlay.style.top = '0';
          gridOverlay.width = totalW;
          gridOverlay.height = totalH;
          gridOverlay.style.width = totalW + 'px';
          gridOverlay.style.height = totalH + 'px';
          gridWrapper.style.width = totalW + 'px';
          gridWrapper.style.height = totalH + 'px';
          applyZoom();
          drawOverlay();
          runAutoDetect();
        }
        gridImg.onload = sizeOverlay;
        gridEditor.classList.add('visible');
        outputEl.classList.remove('visible');
        if (gridImg.complete) setTimeout(sizeOverlay, 0);
      }

      function applyZoom() {
        var zoom = getZoom();
        document.getElementById('zoom-value').textContent = zoom.toFixed(1);
        if (baseWidth && baseHeight) {
          var totalW = baseWidth + 2 * MARGIN;
          var totalH = baseHeight + 2 * MARGIN;
          gridWrapper.style.transformOrigin = 'center top';
          gridWrapper.style.transform = 'scale(' + zoom + ')';
          gridWrapper.style.width = (totalW * zoom) + 'px';
          gridWrapper.style.height = (totalH * zoom) + 'px';
        }
      }

      function runAutoDetect() {
        if (!currentImage || typeof gridDetect === 'undefined' || !gridDetect.detectGridLines) return false;
        var fmt = getGridFormat();
        var result = gridDetect.detectGridLines(currentImage, {
          blackThreshold: 100,
          darknessThreshold: 0.12,
          minLinePx: 1,
          minGap: 6,
          gridCols: fmt.cols,
          gridRows: fmt.rows
        });
        var wantX = fmt.cols + 1;
        var wantY = fmt.rows + 1;
        if (!result || !result.xBounds || result.xBounds.length !== wantX || !result.yBounds || result.yBounds.length !== wantY) return false;
        xBounds = result.xBounds.slice();
        yBounds = result.yBounds.slice();
        drawOverlay();
        return true;
      }

      function handleFile(file) {
        clearError();
        if (!file || !file.type.startsWith('image/')) {
          showError('Please drop or select an image file.');
          return;
        }
        var url = URL.createObjectURL(file);
        if (objectUrl) URL.revokeObjectURL(objectUrl);
        objectUrl = url;
        var img = new Image();
        img.onload = function () {
          setupGridEditor(img);
        };
        img.onerror = function () {
          showError('Could not load the image.');
        };
        img.src = url;
      }

      function runCut() {
        if (!currentImage || typeof gridSplit === 'undefined' || !gridSplit.splitGridCustom) {
          showError('Grid splitter not loaded.');
          return;
        }
        clearError();
        var fmt = getGridFormat();
        var expectedCount = fmt.rows * fmt.cols;
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var clamp = function (v, lo, hi) { return Math.max(lo, Math.min(hi, v)); };
        var xClamped = xBounds.map(function (v) { return clamp(v, 0, w); });
        var yClamped = yBounds.map(function (v) { return clamp(v, 0, h); });
        gridSplit.splitGridCustom(currentImage, xClamped, yClamped, { trimPixels: getTrimPixels() })
          .then(function (blobs) {
            if (blobs.length !== expectedCount) {
              showError('Expected ' + expectedCount + ' tiles, got ' + blobs.length);
              return;
            }
            tileBlobs = blobs;
            previewGrid.innerHTML = '';
            previewGrid.style.gridTemplateColumns = 'repeat(' + fmt.cols + ', 1fr)';
            blobs.forEach(function (blob, index) {
              var r = Math.floor(index / fmt.cols);
              var c = index % fmt.cols;
              var defaultName = 'tile_' + r + '_' + c + '.png';
              var wrap = document.createElement('div');
              wrap.className = 'preview-tile';
              var imgWrap = document.createElement('div');
              imgWrap.className = 'tile-img-wrap';
              var thumb = document.createElement('img');
              thumb.src = URL.createObjectURL(blob);
              thumb.alt = 'Tile ' + (index + 1);
              imgWrap.appendChild(thumb);
              var input = document.createElement('input');
              input.type = 'text';
              input.className = 'tile-name';
              input.value = defaultName;
              input.setAttribute('data-index', index);
              input.placeholder = 'filename.png';
              input.title = 'Rename before download';
              wrap.appendChild(imgWrap);
              wrap.appendChild(input);
              previewGrid.appendChild(wrap);
            });
            outputEl.classList.add('visible');
            downloadBtn.disabled = false;

            var autoNameCheckbox = document.getElementById('auto-name-from-labels');
            var detectingEl = document.getElementById('detecting-labels');
            if (autoNameCheckbox && autoNameCheckbox.checked && typeof Tesseract !== 'undefined' && Tesseract.recognize) {
              detectingEl.style.display = 'block';
              var thumbs = previewGrid.querySelectorAll('.tile-img-wrap img');
              var inputs = previewGrid.querySelectorAll('.tile-name');
              var labelPct = getLabelRegionPct();
              var indices = [];
              for (var k = 0; k < expectedCount; k++) indices.push(k);
              Promise.all(indices.map(function (index) {
                var r = Math.floor(index / fmt.cols);
                var c = index % fmt.cols;
                var defaultBase = 'tile_' + r + '_' + c;
                return getLabelRegionCanvas(thumbs[index].src, labelPct).then(function (labelCanvas) {
                  return Tesseract.recognize(labelCanvas, 'eng').then(function (result) {
                    var words = extractWordsFromOcrResult(result);
                    var base = wordsToBaseName(words);
                    return base ? base : defaultBase;
                  });
                }).catch(function () { return defaultBase; });
              })).then(function (baseNames) {
                var used = {};
                var finalNames = [];
                for (var i = 0; i < expectedCount; i++) {
                  var base = baseNames[i];
                  var name = base + '.png';
                  if (used[name]) {
                    var n = 1;
                    while (used[base + '_' + n + '.png']) n++;
                    name = base + '_' + n + '.png';
                  }
                  used[name] = true;
                  finalNames.push(name);
                }
                for (var j = 0; j < expectedCount; j++) {
                  if (inputs[j]) inputs[j].value = finalNames[j];
                }
                detectingEl.style.display = 'none';
              }).catch(function () {
                detectingEl.style.display = 'none';
              });
            }
          })
          .catch(function (err) {
            showError(err && err.message ? err.message : 'Failed to create tiles.');
          });
      }

      gridOverlay.addEventListener('mousedown', function (e) {
        var rect = gridOverlay.getBoundingClientRect();
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var imgX = (e.clientX - rect.left - MARGIN) / (baseWidth || 1) * w;
        var imgY = (e.clientY - rect.top - MARGIN) / (baseHeight || 1) * h;
        var hit = hitLine(imgX, imgY);
        if (hit) {
          e.preventDefault();
          drag.active = true;
          drag.axis = hit.axis;
          drag.index = hit.index;
        }
      });
      document.addEventListener('mousemove', function (e) {
        if (!drag.active || !currentImage) return;
        var rect = gridOverlay.getBoundingClientRect();
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var marginImgX = MARGIN * w / (baseWidth || 1);
        var marginImgY = MARGIN * h / (baseHeight || 1);
        var displayX = (e.clientX - rect.left - MARGIN) / (baseWidth || 1) * w;
        var displayY = (e.clientY - rect.top - MARGIN) / (baseHeight || 1) * h;
        var pt = {
          x: Math.max(-marginImgX, Math.min(w + marginImgX, displayX)),
          y: Math.max(-marginImgY, Math.min(h + marginImgY, displayY))
        };
        if (drag.axis === 'v') {
          var minX = drag.index > 0 ? xBounds[drag.index - 1] + 2 : -marginImgX;
          var maxX = drag.index < xBounds.length - 1 ? xBounds[drag.index + 1] - 2 : w + marginImgX;
          xBounds[drag.index] = Math.max(minX, Math.min(maxX, pt.x));
        } else {
          var minY = drag.index > 0 ? yBounds[drag.index - 1] + 2 : -marginImgY;
          var maxY = drag.index < yBounds.length - 1 ? yBounds[drag.index + 1] - 2 : h + marginImgY;
          yBounds[drag.index] = Math.max(minY, Math.min(maxY, pt.y));
        }
        drawOverlay();
      });
      document.addEventListener('mouseup', function () {
        drag.active = false;
        drag.axis = null;
        drag.index = null;
      });

      document.getElementById('loupe-btn').addEventListener('click', function () {
        loupeOn = !loupeOn;
        this.classList.toggle('active', loupeOn);
        this.setAttribute('aria-pressed', loupeOn);
        if (!loupeOn) loupeContainer.classList.remove('visible');
      });
      document.addEventListener('mousemove', function (e) {
        if (loupeOn) updateLoupe(e.clientX, e.clientY);
      });

      document.getElementById('zoom').addEventListener('input', function () {
        applyZoom();
      });
      document.getElementById('line-thickness').addEventListener('input', function () {
        var v = this.value;
        document.getElementById('line-thickness-value').textContent = v;
        var trimMain = document.getElementById('trim-pixels');
        var trimInline = document.getElementById('trim-pixels-inline');
        if (trimMain) trimMain.value = v;
        if (trimInline) trimInline.value = v;
        drawOverlay();
      });

      function updateCutButtonLabel() {
        var fmt = getGridFormat();
        var n = fmt.rows * fmt.cols;
        var btn = document.getElementById('cut-btn');
        if (btn) btn.textContent = 'Cut and create ' + n + ' image' + (n !== 1 ? 's' : '');
      }
      var gridFormatHover = null;
      function syncGridFormatVisual() {
        gridFormatHover = null;
        var sel = document.getElementById('grid-format');
        var valueEl = document.getElementById('grid-format-value');
        var gridEl = document.getElementById('grid-format-visual');
        if (!sel || !valueEl || !gridEl) return;
        var v = (sel.value || '4_4').split('_');
        var rows = Math.max(1, Math.min(4, parseInt(v[0], 10) || 4));
        var cols = Math.max(1, Math.min(4, parseInt(v[1], 10) || 4));
        valueEl.textContent = rows + '×' + cols;
        var cells = gridEl.querySelectorAll('.grid-format-picker__cell');
        for (var i = 0; i < cells.length; i++) {
          var r = parseInt(cells[i].getAttribute('data-row'), 10);
          var c = parseInt(cells[i].getAttribute('data-col'), 10);
          cells[i].classList.toggle('in-selection', r < rows && c < cols);
          cells[i].classList.remove('out-of-preview');
        }
      }
      function updateGridFormatHoverPreview(hoverR, hoverC) {
        var gridEl = document.getElementById('grid-format-visual');
        if (!gridEl) return;
        var cells = gridEl.querySelectorAll('.grid-format-picker__cell');
        for (var i = 0; i < cells.length; i++) {
          var r = parseInt(cells[i].getAttribute('data-row'), 10);
          var c = parseInt(cells[i].getAttribute('data-col'), 10);
          var inPreview = r <= hoverR && c <= hoverC;
          cells[i].classList.toggle('in-selection', inPreview);
          cells[i].classList.toggle('out-of-preview', !inPreview);
        }
      }
      function initGridFormatPicker() {
        var gridEl = document.getElementById('grid-format-visual');
        var sel = document.getElementById('grid-format');
        if (!gridEl || !sel) return;
        gridEl.innerHTML = '';
        for (var r = 0; r < 4; r++) {
          for (var c = 0; c < 4; c++) {
            var cell = document.createElement('button');
            cell.type = 'button';
            cell.className = 'grid-format-picker__cell';
            cell.setAttribute('data-row', r);
            cell.setAttribute('data-col', c);
            cell.setAttribute('aria-label', (r + 1) + ' by ' + (c + 1) + ' grid');
            (function (row, col) {
              cell.addEventListener('click', function () {
                sel.value = (row + 1) + '_' + (col + 1);
                sel.dispatchEvent(new Event('change', { bubbles: true }));
              });
              cell.addEventListener('mouseenter', function () {
                gridFormatHover = { r: row, c: col };
                updateGridFormatHoverPreview(row, col);
              });
            })(r, c);
            gridEl.appendChild(cell);
          }
        }
        gridEl.addEventListener('mouseleave', function () {
          gridFormatHover = null;
          syncGridFormatVisual();
        });
        syncGridFormatVisual();
      }
      initGridFormatPicker();
      updateCutButtonLabel();
      document.getElementById('grid-format').addEventListener('change', function () {
        syncGridFormatVisual();
        updateCutButtonLabel();
        if (currentImage) {
          initBounds(currentImage.naturalWidth, currentImage.naturalHeight);
          drawOverlay();
        }
      });
      document.getElementById('auto-detect-btn').addEventListener('click', function () {
        clearError();
        if (!currentImage) {
          showError('Load an image first.');
          return;
        }
        if (!runAutoDetect()) showError('Could not detect grid. Try adjusting lines manually.');
      });
      document.getElementById('reset-lines').addEventListener('click', function () {
        if (currentImage) {
          initBounds(currentImage.naturalWidth, currentImage.naturalHeight);
          drawOverlay();
        }
      });
      document.getElementById('cut-btn').addEventListener('click', runCut);
      var trimMain = document.getElementById('trim-pixels');
      var trimInline = document.getElementById('trim-pixels-inline');
      var lineThicknessEl = document.getElementById('line-thickness');
      var lineThicknessValueEl = document.getElementById('line-thickness-value');
      function syncTrimAndLineThickness(fromTrim) {
        var v = fromTrim;
        if (lineThicknessEl) {
          lineThicknessEl.value = v;
          if (lineThicknessValueEl) lineThicknessValueEl.textContent = v;
        }
        drawOverlay();
      }
      if (trimInline) {
        trimInline.addEventListener('input', function () {
          if (trimMain) trimMain.value = trimInline.value;
          syncTrimAndLineThickness(trimInline.value);
        });
      }
      if (trimMain) {
        trimMain.addEventListener('input', function () {
          trimInline.value = trimMain.value;
          syncTrimAndLineThickness(trimMain.value);
        });
      }

      dropZone.addEventListener('click', function (e) {
        if (e.target.id !== 'browse-btn') fileInput.click();
      });
      document.getElementById('browse-btn').addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        fileInput.click();
      });
      dropZone.addEventListener('dragover', function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'copy';
        dropZone.classList.add('dragover');
      });
      dropZone.addEventListener('dragleave', function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (!dropZone.contains(e.relatedTarget)) dropZone.classList.remove('dragover');
      });
      dropZone.addEventListener('drop', function (e) {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('dragover');
        var file = e.dataTransfer.files && e.dataTransfer.files[0];
        handleFile(file);
      });
      fileInput.addEventListener('change', function () {
        handleFile(fileInput.files[0]);
      });

      function sanitizeZipName(val) {
        var s = (val || '').trim().replace(/[/\\:*?"<>|]/g, '_');
        if (!s) return 'tile.png';
        if (!/\.png$/i.test(s)) s = s.replace(/\.[^.]+$/, '') + '.png';
        return s || 'tile.png';
      }

      function ocrTextToBaseName(text) {
        var s = (text || '').trim().toLowerCase().replace(/[\s/\\:*?"<>|]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '');
        if (!s || s.length < 2) return null;
        var maxLen = 50;
        if (s.length > maxLen) s = s.slice(0, maxLen).replace(/_$/, '');
        return s || null;
      }

      function isWordLike(text) {
        if (!text || typeof text !== 'string') return false;
        var t = text.trim();
        if (t.length < 2) return false;
        return /^[a-zA-Z][a-zA-Z'\u2019-]*[a-zA-Z]$|^[a-zA-Z]{2,}$/.test(t) || /^[a-zA-Z]+$/.test(t);
      }

      function extractWordsFromOcrResult(result) {
        var words = result && result.data && result.data.words;
        if (!words || !Array.isArray(words)) return [];
        var out = [];
        for (var i = 0; i < words.length; i++) {
          var w = words[i];
          var text = (w && w.text && w.text.trim()) || '';
          if (isWordLike(text)) out.push(text);
        }
        return out;
      }

      function wordsToBaseName(words) {
        if (!words || words.length === 0) return null;
        var s = words.join('_').toLowerCase().replace(/['\u2019]/g, '').replace(/[^a-z0-9_]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '');
        if (!s || s.length < 2) return null;
        if (s.length > 50) s = s.slice(0, 50).replace(/_$/, '');
        return s || null;
      }

      function getLabelRegionCanvas(imageUrl, bottomPercent) {
        return new Promise(function (resolve, reject) {
          var img = new Image();
          if (imageUrl.indexOf('blob:') !== 0) img.crossOrigin = 'anonymous';
          img.onload = function () {
            var w = img.naturalWidth;
            var h = img.naturalHeight;
            var sliceH = Math.max(1, Math.floor((bottomPercent / 100) * h));
            var canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = sliceH;
            var ctx = canvas.getContext('2d');
            if (!ctx) { reject(new Error('No 2d context')); return; }
            ctx.drawImage(img, 0, h - sliceH, w, sliceH, 0, 0, w, sliceH);
            resolve(canvas);
          };
          img.onerror = function () { reject(new Error('Failed to load image for label region')); };
          img.src = imageUrl;
        });
      }

      downloadBtn.addEventListener('click', function () {
        if (!tileBlobs.length) return;
        downloadBtn.disabled = true;
        var zip = new JSZip();
        var inputs = previewGrid.querySelectorAll('.tile-name');
        var used = {};
        for (var i = 0; i < tileBlobs.length; i++) {
          var name = sanitizeZipName(inputs[i] ? inputs[i].value : '');
          if (used[name]) {
            var base = name.replace(/\.png$/i, '');
            var n = 1;
            while (used[base + '_' + n + '.png']) n++;
            name = base + '_' + n + '.png';
            used[name] = true;
          } else {
            used[name] = true;
          }
          zip.file(name, tileBlobs[i], { binary: true });
        }
        zip.generateAsync({ type: 'blob' }).then(function (blob) {
          var a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'grid-tiles.zip';
          a.click();
          URL.revokeObjectURL(a.href);
          downloadBtn.disabled = false;
        }).catch(function () {
          showError('Failed to create ZIP.');
          downloadBtn.disabled = false;
        });
      });
    })();
  </script>
  <script src="js/auth0-config.js"></script>
  <script type="module" src="js/auth.js"></script>
  <script src="js/auth-ui.js"></script>
</body>
</html>
