<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4×4 Grid Image Splitter</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script src="js/gridSplit.js"></script>
  <script src="js/gridDetect.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 50%;
      margin: 0 auto;
      padding: 2rem 1.5rem;
      min-height: 100vh;
      background: #fafafa;
    }
    .page-header {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    h1 {
      font-size: 1.75rem;
      font-weight: 700;
      margin: 0 0 0.75rem 0;
      color: #1a1a1a;
    }
    .intro {
      font-size: 0.95rem;
      color: #555;
      line-height: 1.5;
      margin: 0;
      max-width: 42rem;
      margin-left: auto;
      margin-right: auto;
    }
    .drop-section {
      background: #fff;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .drop-zone {
      display: block;
      border: 2px dashed #888;
      border-radius: 8px;
      padding: 2.5rem 2rem;
      text-align: center;
      cursor: pointer;
      background: #f8f8f8;
      transition: background 0.15s, border-color 0.15s;
      position: relative;
    }
    .drop-zone:hover, .drop-zone.dragover {
      background: #eee;
      border-color: #555;
    }
    .drop-zone.dragover {
      border-color: #333;
      background: #e8e8e8;
    }
    .drop-zone p { margin: 0; color: #555; }
    .drop-zone .drop-title { font-weight: 600; color: #333; margin-bottom: 0.25rem; }
    .drop-zone .drop-hint { font-size: 0.9rem; color: #777; margin-bottom: 0.5rem; }
    .drop-zone .format-hint {
      font-size: 0.8rem;
      color: #888;
      margin-top: 0.5rem;
    }
    .browse-btn {
      display: inline-block;
      margin-top: 0.75rem;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      color: #333;
      background: #fff;
      border: 1px solid #888;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }
    .browse-btn:hover {
      background: #e8e8e8;
      border-color: #555;
    }
    #file-input { display: none; }
    .trim-row { margin-top: 1rem; font-size: 0.9rem; }
    .trim-row label { margin-right: 0.5rem; }
    .trim-hint { color: #888; margin-left: 0.5rem; font-size: 0.85rem; }
    .download-hint { font-size: 0.8rem; color: #888; margin-top: 0.5rem; margin-bottom: 0; }
    .error { color: #c00; margin-top: 0.5rem; font-size: 0.9rem; }
    .output {
      margin-top: 1.5rem;
      display: none;
      background: #fff;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .output.visible { display: block; }
    .output h2 { font-size: 1rem; margin: 0 0 0.25rem 0; color: #333; }
    .output-hint { font-size: 0.85rem; color: #666; margin: 0 0 0.5rem 0; }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin-bottom: 1rem;
      max-width: 100%;
      align-items: start;
    }
    .preview-tile {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      align-items: stretch;
    }
    .preview-tile .tile-img-wrap {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      background: #eee;
      border-radius: 4px;
      overflow: hidden;
    }
    .preview-tile .tile-img-wrap img {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      object-position: center;
    }
    .preview-tile .tile-name {
      width: 100%;
      box-sizing: border-box;
      padding: 0.4rem 0.5rem;
      font-size: 0.8rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      text-align: center;
      min-height: 2.25rem;
    }
    .preview-tile .tile-name:focus {
      border-color: #333;
      outline: none;
    }
    .btn {
      display: inline-block;
      padding: 0.6rem 1.2rem;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
    }
    .btn:hover { background: #555; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .nav-link {
      display: inline-block;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
      text-decoration: none;
    }
    .nav-link:hover { color: #333; text-decoration: underline; }
    .grid-editor {
      display: none;
      margin-top: 1rem;
      background: #fff;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .grid-editor.visible { display: block; }
    .grid-editor h2 { font-size: 1rem; margin: 0 0 0.75rem 0; color: #333; }
    .grid-editor-toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .grid-editor-toolbar label { font-size: 0.9rem; }
    .grid-editor-toolbar input[type="range"] { vertical-align: middle; }
    .loupe-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      padding: 0;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
      color: #555;
    }
    .loupe-btn:hover { background: #f0f0f0; color: #333; }
    .loupe-btn.active { background: #e0e8f0; border-color: #333; color: #1a1a1a; }
    .loupe-btn svg { width: 20px; height: 20px; }
    .loupe-container {
      position: fixed;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid #333;
      box-shadow: 0 4px 16px rgba(0,0,0,0.25);
      pointer-events: none;
      z-index: 1000;
      display: none;
    }
    .loupe-container.visible { display: block; }
    .loupe-container canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .grid-preview-scroll {
      overflow: auto;
      max-height: 70vh;
      margin-bottom: 1rem;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    .grid-preview-wrapper {
      position: relative;
      display: block;
      transform-origin: center top;
      flex-shrink: 0;
    }
    .grid-overlay {
      position: absolute;
      left: 0;
      top: 0;
      cursor: crosshair;
      pointer-events: auto;
    }
    .grid-editor-buttons { margin-top: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; }
    .grid-editor-buttons .btn { margin-right: 0; }
    .trim-inline { display: inline-flex; align-items: center; gap: 0.35rem; font-size: 0.9rem; }
    .trim-inline input { padding: 0.25rem 0.35rem; }
    .auto-name-label { display: inline-flex; align-items: center; gap: 0.35rem; font-size: 0.9rem; cursor: pointer; }
    .detecting-labels { font-size: 0.9rem; color: #666; margin: 0.25rem 0 0.5rem 0; }
    .btn-secondary {
      background: #666;
      color: #fff;
    }
    .btn-secondary:hover { background: #555; }
  </style>
</head>
<body>
  <header class="page-header">
    <h1>Grid Image Splitter</h1>
    <p class="intro">Upload a single image that contains a 4×4 grid (e.g. from ChatGPT). The app splits it into 16 separate images with no borders. Then download all of them in one ZIP file.</p>
    <a class="nav-link" href="prompt-builder.html">Prompt builder</a>
  </header>

  <section class="drop-section">
    <div class="drop-zone" id="drop-zone">
      <p class="drop-title">Drop your 4×4 grid image here</p>
      <p class="drop-hint">or click to select a file</p>
      <p class="format-hint">Supports PNG, JPG, WebP.</p>
      <button type="button" class="browse-btn" id="browse-btn">Browse files…</button>
    </div>
    <input type="file" id="file-input" accept="image/png,image/jpeg,image/jpg,image/webp" aria-label="Choose 4×4 grid image">
    <p class="trim-row">
      <label for="trim-pixels">Border trim (px):</label>
      <input type="number" id="trim-pixels" min="0" max="20" value="4" step="1" aria-label="Pixels to remove from each tile edge" style="width: 4em;">
      <span class="trim-hint">Remove grid lines from each tile (set before Cut; 4–6 px often needed for ChatGPT grids)</span>
    </p>
  </section>
  <p class="error" id="error" aria-live="polite"></p>

  <section class="grid-editor" id="grid-editor" aria-label="Adjust cutting lines">
    <h2>Adjust cutting lines</h2>
    <p class="intro" style="margin-bottom: 0.75rem;">Grid and outer border are <strong>auto-detected when you upload</strong>. You can drag the <strong>blue</strong> (outer) and <strong>red</strong> (inner) lines to adjust, or click Auto-detect grid to run detection again.</p>
    <div class="grid-editor-toolbar">
      <label>Zoom: <span id="zoom-value">1</span>×</label>
      <input type="range" id="zoom" min="0.5" max="2.5" step="0.1" value="1" aria-label="Zoom">
      <label>Line thickness: <span id="line-thickness-value">2</span>px</label>
      <input type="range" id="line-thickness" min="1" max="5" step="1" value="2" aria-label="Cutting line thickness">
      <button type="button" class="loupe-btn" id="loupe-btn" title="Toggle 4× loupe (follows cursor)" aria-pressed="false">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
      </button>
    </div>
    <div class="grid-preview-scroll" id="grid-preview-scroll">
      <div class="grid-preview-wrapper" id="grid-preview-wrapper">
        <img id="grid-image" alt="Your grid image">
        <canvas id="grid-overlay" class="grid-overlay" aria-hidden="true"></canvas>
      </div>
    </div>
    <div class="grid-editor-buttons">
      <span class="trim-inline">
        <label for="trim-pixels-inline">Trim:</label>
        <input type="number" id="trim-pixels-inline" min="0" max="20" value="4" step="1" style="width: 3.5em;" title="Pixels to remove from each side of every tile">
      </span>
      <label class="auto-name-label">
        <input type="checkbox" id="auto-name-from-labels" checked aria-describedby="auto-name-hint">
        Auto-name from labels
      </label>
      <span class="trim-hint" id="auto-name-hint" style="margin-left: 0.25rem;">Detect text in each tile and use it as the filename.</span>
      <button type="button" class="btn btn-secondary" id="auto-detect-btn">Auto-detect grid</button>
      <button type="button" class="btn btn-secondary" id="reset-lines">Reset lines</button>
      <button type="button" class="btn" id="cut-btn">Cut and create 16 images</button>
    </div>
  </section>

  <div class="loupe-container" id="loupe-container" aria-hidden="true">
    <canvas id="loupe-canvas" width="120" height="120"></canvas>
  </div>

  <section class="output" id="output" aria-label="Split result">
    <h2>Preview: 16 tiles</h2>
    <p class="output-hint">Rename each file below if you like, then download.</p>
    <p class="detecting-labels" id="detecting-labels" aria-live="polite" style="display: none;">Detecting labels…</p>
    <div class="preview-grid" id="preview-grid"></div>
    <button type="button" class="btn" id="download-zip">Download all as ZIP</button>
    <p class="download-hint">If Windows blocks the file, right-click it → Properties → check Unblock → OK.</p>
  </section>

  <script>
    (function () {
      var dropZone = document.getElementById('drop-zone');
      var fileInput = document.getElementById('file-input');
      var errorEl = document.getElementById('error');
      var outputEl = document.getElementById('output');
      var previewGrid = document.getElementById('preview-grid');
      var downloadBtn = document.getElementById('download-zip');

      var tileBlobs = [];
      var objectUrl = null;
      var currentImage = null;
      var xBounds = [];
      var yBounds = [];
      var drag = { active: false, axis: null, index: null };
      var gridImg = document.getElementById('grid-image');
      var gridOverlay = document.getElementById('grid-overlay');
      var gridWrapper = document.getElementById('grid-preview-wrapper');
      var gridScroll = document.getElementById('grid-preview-scroll');
      var gridEditor = document.getElementById('grid-editor');
      var baseWidth = 0;
      var baseHeight = 0;
      var loupeOn = false;
      var loupeContainer = document.getElementById('loupe-container');
      var loupeCanvas = document.getElementById('loupe-canvas');
      var LOUPE_SIZE = 120;
      var LOUPE_ZOOM = 4;
      var MARGIN = 10;

      function getTrimPixels() {
        var el = document.getElementById('trim-pixels-inline') || document.getElementById('trim-pixels');
        return el ? Math.max(0, parseInt(el.value, 10) || 0) : 0;
      }
      function getZoom() {
        var el = document.getElementById('zoom');
        return el ? parseFloat(el.value) || 1 : 1;
      }
      function getLineThickness() {
        var el = document.getElementById('line-thickness');
        return el ? Math.max(1, parseInt(el.value, 10) || 2) : 2;
      }

      function clearError() {
        errorEl.textContent = '';
      }
      function showError(msg) {
        errorEl.textContent = msg;
      }

      function initBounds(w, h) {
        xBounds = [0, w / 4, w / 2, (3 * w) / 4, w];
        yBounds = [0, h / 4, h / 2, (3 * h) / 4, h];
      }

      function updateLoupe(clientX, clientY) {
        if (!loupeOn || !loupeContainer || !loupeCanvas || !currentImage) return;
        var rect = gridOverlay.getBoundingClientRect();
        if (clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) {
          loupeContainer.classList.remove('visible');
          return;
        }
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var imgX = (clientX - rect.left - MARGIN) / (baseWidth || 1) * w;
        var imgY = (clientY - rect.top - MARGIN) / (baseHeight || 1) * h;
        var halfRegion = (LOUPE_SIZE / LOUPE_ZOOM) / 2;
        var sx = Math.max(0, imgX - halfRegion);
        var sy = Math.max(0, imgY - halfRegion);
        var sw = Math.min(w - sx, halfRegion * 2);
        var sh = Math.min(h - sy, halfRegion * 2);
        if (sw <= 0 || sh <= 0) return;
        loupeContainer.style.left = (clientX - LOUPE_SIZE / 2) + 'px';
        loupeContainer.style.top = (clientY - LOUPE_SIZE / 2) + 'px';
        var ctx = loupeCanvas.getContext('2d');
        ctx.save();
        ctx.beginPath();
        ctx.arc(LOUPE_SIZE / 2, LOUPE_SIZE / 2, LOUPE_SIZE / 2, 0, 2 * Math.PI);
        ctx.clip();
        ctx.drawImage(currentImage, sx, sy, sw, sh, 0, 0, LOUPE_SIZE, LOUPE_SIZE);
        function toLoupeX(px) { return ((px - sx) / sw) * LOUPE_SIZE; }
        function toLoupeY(py) { return ((py - sy) / sh) * LOUPE_SIZE; }
        var lw = Math.max(1.5, 2);
        ctx.strokeStyle = 'rgba(50, 100, 220, 0.95)';
        ctx.lineWidth = lw;
        ctx.beginPath();
        ctx.moveTo(toLoupeX(xBounds[0]), 0);
        ctx.lineTo(toLoupeX(xBounds[0]), LOUPE_SIZE);
        ctx.moveTo(toLoupeX(xBounds[4]), 0);
        ctx.lineTo(toLoupeX(xBounds[4]), LOUPE_SIZE);
        ctx.moveTo(0, toLoupeY(yBounds[0]));
        ctx.lineTo(LOUPE_SIZE, toLoupeY(yBounds[0]));
        ctx.moveTo(0, toLoupeY(yBounds[4]));
        ctx.lineTo(LOUPE_SIZE, toLoupeY(yBounds[4]));
        ctx.stroke();
        ctx.strokeStyle = 'rgba(220, 50, 50, 0.9)';
        ctx.lineWidth = lw;
        ctx.beginPath();
        for (var i = 1; i <= 3; i++) {
          var lx = toLoupeX(xBounds[i]);
          if (lx >= -1 && lx <= LOUPE_SIZE + 1) {
            ctx.moveTo(lx, 0);
            ctx.lineTo(lx, LOUPE_SIZE);
          }
        }
        for (var j = 1; j <= 3; j++) {
          var ly = toLoupeY(yBounds[j]);
          if (ly >= -1 && ly <= LOUPE_SIZE + 1) {
            ctx.moveTo(0, ly);
            ctx.lineTo(LOUPE_SIZE, ly);
          }
        }
        ctx.stroke();
        ctx.restore();
        loupeContainer.classList.add('visible');
      }

      function drawOverlay() {
        if (!currentImage || !gridOverlay) return;
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var cw = gridOverlay.width;
        var ch = gridOverlay.height;
        if (cw <= 0 || ch <= 0) return;
        var ctx = gridOverlay.getContext('2d');
        ctx.clearRect(0, 0, cw, ch);
        var thickness = Math.max(1, getLineThickness());
        function dispX(px) { return MARGIN + (px / w) * baseWidth; }
        function dispY(py) { return MARGIN + (py / h) * baseHeight; }
        // Outer cut lines (blue)
        ctx.strokeStyle = 'rgba(50, 100, 220, 0.95)';
        ctx.lineWidth = Math.max(2, thickness);
        ctx.beginPath();
        ctx.moveTo(dispX(xBounds[0]), 0);
        ctx.lineTo(dispX(xBounds[0]), ch);
        ctx.moveTo(dispX(xBounds[4]), 0);
        ctx.lineTo(dispX(xBounds[4]), ch);
        ctx.moveTo(0, dispY(yBounds[0]));
        ctx.lineTo(cw, dispY(yBounds[0]));
        ctx.moveTo(0, dispY(yBounds[4]));
        ctx.lineTo(cw, dispY(yBounds[4]));
        ctx.stroke();
        // Inner grid lines (red)
        ctx.strokeStyle = 'rgba(220, 50, 50, 0.9)';
        ctx.lineWidth = thickness;
        ctx.beginPath();
        for (var i = 1; i <= 3; i++) {
          ctx.moveTo(dispX(xBounds[i]), 0);
          ctx.lineTo(dispX(xBounds[i]), ch);
        }
        for (var j = 1; j <= 3; j++) {
          ctx.moveTo(0, dispY(yBounds[j]));
          ctx.lineTo(cw, dispY(yBounds[j]));
        }
        ctx.stroke();
      }

      function hitLine(imgX, imgY) {
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var hitPx = Math.max(8, w / 80);
        for (var i = 0; i <= 4; i++) {
          if (Math.abs(imgX - xBounds[i]) <= hitPx) return { axis: 'v', index: i };
        }
        for (var j = 0; j <= 4; j++) {
          if (Math.abs(imgY - yBounds[j]) <= hitPx) return { axis: 'h', index: j };
        }
        return null;
      }

      function setupGridEditor(img) {
        currentImage = img;
        var w = img.naturalWidth;
        var h = img.naturalHeight;
        initBounds(w, h);
        gridImg.src = img.src;
        function sizeOverlay() {
          var w = currentImage.naturalWidth;
          var h = currentImage.naturalHeight;
          var maxDisplay = 560;
          if (w >= h) {
            baseWidth = Math.min(w, maxDisplay);
            baseHeight = Math.round((h / w) * baseWidth);
          } else {
            baseHeight = Math.min(h, maxDisplay);
            baseWidth = Math.round((w / h) * baseHeight);
          }
          if (!baseWidth || !baseHeight) return;
          var totalW = baseWidth + 2 * MARGIN;
          var totalH = baseHeight + 2 * MARGIN;
          gridImg.style.position = 'absolute';
          gridImg.style.left = MARGIN + 'px';
          gridImg.style.top = MARGIN + 'px';
          gridImg.style.width = baseWidth + 'px';
          gridImg.style.height = baseHeight + 'px';
          gridImg.style.maxWidth = 'none';
          gridOverlay.style.left = '0';
          gridOverlay.style.top = '0';
          gridOverlay.width = totalW;
          gridOverlay.height = totalH;
          gridOverlay.style.width = totalW + 'px';
          gridOverlay.style.height = totalH + 'px';
          gridWrapper.style.width = totalW + 'px';
          gridWrapper.style.height = totalH + 'px';
          applyZoom();
          drawOverlay();
          runAutoDetect();
        }
        gridImg.onload = sizeOverlay;
        gridEditor.classList.add('visible');
        outputEl.classList.remove('visible');
        if (gridImg.complete) setTimeout(sizeOverlay, 0);
      }

      function applyZoom() {
        var zoom = getZoom();
        document.getElementById('zoom-value').textContent = zoom.toFixed(1);
        if (baseWidth && baseHeight) {
          var totalW = baseWidth + 2 * MARGIN;
          var totalH = baseHeight + 2 * MARGIN;
          gridWrapper.style.transformOrigin = 'center top';
          gridWrapper.style.transform = 'scale(' + zoom + ')';
          gridWrapper.style.width = (totalW * zoom) + 'px';
          gridWrapper.style.height = (totalH * zoom) + 'px';
        }
      }

      function runAutoDetect() {
        if (!currentImage || typeof gridDetect === 'undefined' || !gridDetect.detectGridLines) return false;
        var result = gridDetect.detectGridLines(currentImage, {
          blackThreshold: 100,
          darknessThreshold: 0.12,
          minLinePx: 1,
          minGap: 6
        });
        if (!result || !result.xBounds || result.xBounds.length !== 5 || !result.yBounds || result.yBounds.length !== 5) return false;
        xBounds = result.xBounds.slice();
        yBounds = result.yBounds.slice();
        drawOverlay();
        return true;
      }

      function handleFile(file) {
        clearError();
        if (!file || !file.type.startsWith('image/')) {
          showError('Please drop or select an image file.');
          return;
        }
        var url = URL.createObjectURL(file);
        if (objectUrl) URL.revokeObjectURL(objectUrl);
        objectUrl = url;
        var img = new Image();
        img.onload = function () {
          setupGridEditor(img);
        };
        img.onerror = function () {
          showError('Could not load the image.');
        };
        img.src = url;
      }

      function runCut() {
        if (!currentImage || typeof gridSplit === 'undefined' || !gridSplit.splitGridCustom) {
          showError('Grid splitter not loaded.');
          return;
        }
        clearError();
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var clamp = function (v, lo, hi) { return Math.max(lo, Math.min(hi, v)); };
        var xClamped = xBounds.map(function (v) { return clamp(v, 0, w); });
        var yClamped = yBounds.map(function (v) { return clamp(v, 0, h); });
        gridSplit.splitGridCustom(currentImage, xClamped, yClamped, { trimPixels: getTrimPixels() })
          .then(function (blobs) {
            if (blobs.length !== 16) {
              showError('Expected 16 tiles, got ' + blobs.length);
              return;
            }
            tileBlobs = blobs;
            previewGrid.innerHTML = '';
            blobs.forEach(function (blob, index) {
              var r = Math.floor(index / 4);
              var c = index % 4;
              var defaultName = 'tile_' + r + '_' + c + '.png';
              var wrap = document.createElement('div');
              wrap.className = 'preview-tile';
              var imgWrap = document.createElement('div');
              imgWrap.className = 'tile-img-wrap';
              var thumb = document.createElement('img');
              thumb.src = URL.createObjectURL(blob);
              thumb.alt = 'Tile ' + (index + 1);
              var input = document.createElement('input');
              input.type = 'text';
              input.className = 'tile-name';
              input.value = defaultName;
              input.setAttribute('data-index', index);
              input.placeholder = 'filename.png';
              input.title = 'Rename before download';
              imgWrap.appendChild(thumb);
              wrap.appendChild(imgWrap);
              wrap.appendChild(input);
              previewGrid.appendChild(wrap);
            });
            outputEl.classList.add('visible');
            downloadBtn.disabled = false;

            var autoNameCheckbox = document.getElementById('auto-name-from-labels');
            var detectingEl = document.getElementById('detecting-labels');
            if (autoNameCheckbox && autoNameCheckbox.checked && typeof Tesseract !== 'undefined' && Tesseract.recognize) {
              detectingEl.style.display = 'block';
              var thumbs = previewGrid.querySelectorAll('.tile-img-wrap img');
              var inputs = previewGrid.querySelectorAll('.tile-name');
              Promise.all([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15].map(function (index) {
                var r = Math.floor(index / 4);
                var c = index % 4;
                var defaultBase = 'tile_' + r + '_' + c;
                return Tesseract.recognize(thumbs[index].src, 'eng').then(function (result) {
                  var text = result && result.data && result.data.text ? result.data.text : '';
                  var base = ocrTextToBaseName(text);
                  return base ? base : defaultBase;
                }).catch(function () { return defaultBase; });
              })).then(function (baseNames) {
                var used = {};
                var finalNames = [];
                for (var i = 0; i < 16; i++) {
                  var base = baseNames[i];
                  var name = base + '.png';
                  if (used[name]) {
                    var n = 1;
                    while (used[base + '_' + n + '.png']) n++;
                    name = base + '_' + n + '.png';
                  }
                  used[name] = true;
                  finalNames.push(name);
                }
                for (var j = 0; j < 16; j++) {
                  if (inputs[j]) inputs[j].value = finalNames[j];
                }
                detectingEl.style.display = 'none';
              }).catch(function () {
                detectingEl.style.display = 'none';
              });
            }
          })
          .catch(function (err) {
            showError(err && err.message ? err.message : 'Failed to create tiles.');
          });
      }

      gridOverlay.addEventListener('mousedown', function (e) {
        var rect = gridOverlay.getBoundingClientRect();
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var imgX = (e.clientX - rect.left - MARGIN) / (baseWidth || 1) * w;
        var imgY = (e.clientY - rect.top - MARGIN) / (baseHeight || 1) * h;
        var hit = hitLine(imgX, imgY);
        if (hit) {
          e.preventDefault();
          drag.active = true;
          drag.axis = hit.axis;
          drag.index = hit.index;
        }
      });
      document.addEventListener('mousemove', function (e) {
        if (!drag.active || !currentImage) return;
        var rect = gridOverlay.getBoundingClientRect();
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var marginImgX = MARGIN * w / (baseWidth || 1);
        var marginImgY = MARGIN * h / (baseHeight || 1);
        var displayX = (e.clientX - rect.left - MARGIN) / (baseWidth || 1) * w;
        var displayY = (e.clientY - rect.top - MARGIN) / (baseHeight || 1) * h;
        var pt = {
          x: Math.max(-marginImgX, Math.min(w + marginImgX, displayX)),
          y: Math.max(-marginImgY, Math.min(h + marginImgY, displayY))
        };
        if (drag.axis === 'v') {
          var minX = drag.index > 0 ? xBounds[drag.index - 1] + 2 : -marginImgX;
          var maxX = drag.index < 4 ? xBounds[drag.index + 1] - 2 : w + marginImgX;
          xBounds[drag.index] = Math.max(minX, Math.min(maxX, pt.x));
        } else {
          var minY = drag.index > 0 ? yBounds[drag.index - 1] + 2 : -marginImgY;
          var maxY = drag.index < 4 ? yBounds[drag.index + 1] - 2 : h + marginImgY;
          yBounds[drag.index] = Math.max(minY, Math.min(maxY, pt.y));
        }
        drawOverlay();
      });
      document.addEventListener('mouseup', function () {
        drag.active = false;
        drag.axis = null;
        drag.index = null;
      });

      document.getElementById('loupe-btn').addEventListener('click', function () {
        loupeOn = !loupeOn;
        this.classList.toggle('active', loupeOn);
        this.setAttribute('aria-pressed', loupeOn);
        if (!loupeOn) loupeContainer.classList.remove('visible');
      });
      document.addEventListener('mousemove', function (e) {
        if (loupeOn) updateLoupe(e.clientX, e.clientY);
      });

      document.getElementById('zoom').addEventListener('input', function () {
        applyZoom();
      });
      document.getElementById('line-thickness').addEventListener('input', function () {
        document.getElementById('line-thickness-value').textContent = this.value;
        drawOverlay();
      });

      document.getElementById('auto-detect-btn').addEventListener('click', function () {
        clearError();
        if (!currentImage) {
          showError('Load an image first.');
          return;
        }
        if (!runAutoDetect()) showError('Could not detect grid. Try adjusting lines manually.');
      });
      document.getElementById('reset-lines').addEventListener('click', function () {
        if (currentImage) {
          initBounds(currentImage.naturalWidth, currentImage.naturalHeight);
          drawOverlay();
        }
      });
      document.getElementById('cut-btn').addEventListener('click', runCut);
      var trimMain = document.getElementById('trim-pixels');
      var trimInline = document.getElementById('trim-pixels-inline');
      if (trimMain && trimInline) {
        trimMain.addEventListener('input', function () { trimInline.value = trimMain.value; });
        trimInline.addEventListener('input', function () { trimMain.value = trimInline.value; });
      }

      dropZone.addEventListener('click', function (e) {
        if (e.target.id !== 'browse-btn') fileInput.click();
      });
      document.getElementById('browse-btn').addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        fileInput.click();
      });
      dropZone.addEventListener('dragover', function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'copy';
        dropZone.classList.add('dragover');
      });
      dropZone.addEventListener('dragleave', function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (!dropZone.contains(e.relatedTarget)) dropZone.classList.remove('dragover');
      });
      dropZone.addEventListener('drop', function (e) {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('dragover');
        var file = e.dataTransfer.files && e.dataTransfer.files[0];
        handleFile(file);
      });
      fileInput.addEventListener('change', function () {
        handleFile(fileInput.files[0]);
      });

      function sanitizeZipName(val) {
        var s = (val || '').trim().replace(/[/\\:*?"<>|]/g, '_');
        if (!s) return 'tile.png';
        if (!/\.png$/i.test(s)) s = s.replace(/\.[^.]+$/, '') + '.png';
        return s || 'tile.png';
      }

      function ocrTextToBaseName(text) {
        var s = (text || '').trim().toLowerCase().replace(/[\s/\\:*?"<>|]/g, '_').replace(/_+/g, '_').replace(/^_|_$/g, '');
        if (!s || s.length < 2) return null;
        var maxLen = 50;
        if (s.length > maxLen) s = s.slice(0, maxLen).replace(/_$/, '');
        return s || null;
      }

      downloadBtn.addEventListener('click', function () {
        if (tileBlobs.length !== 16) return;
        downloadBtn.disabled = true;
        var zip = new JSZip();
        var inputs = previewGrid.querySelectorAll('.tile-name');
        var used = {};
        for (var i = 0; i < 16; i++) {
          var name = sanitizeZipName(inputs[i] ? inputs[i].value : '');
          if (used[name]) {
            var base = name.replace(/\.png$/i, '');
            var n = 1;
            while (used[base + '_' + n + '.png']) n++;
            name = base + '_' + n + '.png';
            used[name] = true;
          } else {
            used[name] = true;
          }
          zip.file(name, tileBlobs[i], { binary: true });
        }
        zip.generateAsync({ type: 'blob' }).then(function (blob) {
          var a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'grid-tiles.zip';
          a.click();
          URL.revokeObjectURL(a.href);
          downloadBtn.disabled = false;
        }).catch(function () {
          showError('Failed to create ZIP.');
          downloadBtn.disabled = false;
        });
      });
    })();
  </script>
</body>
</html>
