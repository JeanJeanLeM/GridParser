<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>4×4 Grid Image Splitter</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="js/gridSplit.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 560px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
      min-height: 100vh;
      background: #fafafa;
    }
    .page-header {
      text-align: center;
      margin-bottom: 1.5rem;
    }
    h1 {
      font-size: 1.75rem;
      font-weight: 700;
      margin: 0 0 0.75rem 0;
      color: #1a1a1a;
    }
    .intro {
      font-size: 0.95rem;
      color: #555;
      line-height: 1.5;
      margin: 0;
      max-width: 420px;
      margin-left: auto;
      margin-right: auto;
    }
    .drop-section {
      background: #fff;
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .drop-zone {
      display: block;
      border: 2px dashed #888;
      border-radius: 8px;
      padding: 2.5rem 2rem;
      text-align: center;
      cursor: pointer;
      background: #f8f8f8;
      transition: background 0.15s, border-color 0.15s;
      position: relative;
    }
    .drop-zone:hover, .drop-zone.dragover {
      background: #eee;
      border-color: #555;
    }
    .drop-zone.dragover {
      border-color: #333;
      background: #e8e8e8;
    }
    .drop-zone p { margin: 0; color: #555; }
    .drop-zone .drop-title { font-weight: 600; color: #333; margin-bottom: 0.25rem; }
    .drop-zone .drop-hint { font-size: 0.9rem; color: #777; margin-bottom: 0.5rem; }
    .drop-zone .format-hint {
      font-size: 0.8rem;
      color: #888;
      margin-top: 0.5rem;
    }
    .browse-btn {
      display: inline-block;
      margin-top: 0.75rem;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      color: #333;
      background: #fff;
      border: 1px solid #888;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }
    .browse-btn:hover {
      background: #e8e8e8;
      border-color: #555;
    }
    #file-input { display: none; }
    .trim-row { margin-top: 1rem; font-size: 0.9rem; }
    .trim-row label { margin-right: 0.5rem; }
    .trim-hint { color: #888; margin-left: 0.5rem; font-size: 0.85rem; }
    .download-hint { font-size: 0.8rem; color: #888; margin-top: 0.5rem; margin-bottom: 0; }
    .error { color: #c00; margin-top: 0.5rem; font-size: 0.9rem; }
    .output {
      margin-top: 1.5rem;
      display: none;
      background: #fff;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .output.visible { display: block; }
    .output h2 { font-size: 1rem; margin: 0 0 0.75rem 0; color: #333; }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 4px;
      margin-bottom: 1rem;
      max-width: 100%;
    }
    .preview-grid img {
      width: 100%;
      height: auto;
      display: block;
      background: #eee;
      border-radius: 4px;
    }
    .btn {
      display: inline-block;
      padding: 0.6rem 1.2rem;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
    }
    .btn:hover { background: #555; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .nav-link {
      display: inline-block;
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
      text-decoration: none;
    }
    .nav-link:hover { color: #333; text-decoration: underline; }
    .grid-editor {
      display: none;
      margin-top: 1rem;
      background: #fff;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    }
    .grid-editor.visible { display: block; }
    .grid-editor h2 { font-size: 1rem; margin: 0 0 0.75rem 0; color: #333; }
    .grid-editor-toolbar {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .grid-editor-toolbar label { font-size: 0.9rem; }
    .grid-editor-toolbar input[type="range"] { vertical-align: middle; }
    .grid-preview-scroll {
      overflow: auto;
      max-height: 70vh;
      margin-bottom: 1rem;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background: #f5f5f5;
    }
    .grid-preview-wrapper {
      position: relative;
      display: inline-block;
      transform-origin: top left;
    }
    .grid-preview-wrapper img { display: block; vertical-align: top; }
    .grid-overlay {
      position: absolute;
      left: 0;
      top: 0;
      cursor: crosshair;
      pointer-events: auto;
    }
    .grid-editor-buttons { margin-top: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; }
    .grid-editor-buttons .btn { margin-right: 0; }
    .trim-inline { display: inline-flex; align-items: center; gap: 0.35rem; font-size: 0.9rem; }
    .trim-inline input { padding: 0.25rem 0.35rem; }
    .btn-secondary {
      background: #666;
      color: #fff;
    }
    .btn-secondary:hover { background: #555; }
  </style>
</head>
<body>
  <header class="page-header">
    <h1>Grid Image Splitter</h1>
    <p class="intro">Upload a single image that contains a 4×4 grid (e.g. from ChatGPT). The app splits it into 16 separate images with no borders. Then download all of them in one ZIP file.</p>
    <a class="nav-link" href="prompt-builder.html">Prompt builder</a>
  </header>

  <section class="drop-section">
    <div class="drop-zone" id="drop-zone">
      <p class="drop-title">Drop your 4×4 grid image here</p>
      <p class="drop-hint">or click to select a file</p>
      <p class="format-hint">Supports PNG, JPG, WebP.</p>
      <button type="button" class="browse-btn" id="browse-btn">Browse files…</button>
    </div>
    <input type="file" id="file-input" accept="image/png,image/jpeg,image/jpg,image/webp" aria-label="Choose 4×4 grid image">
    <p class="trim-row">
      <label for="trim-pixels">Border trim (px):</label>
      <input type="number" id="trim-pixels" min="0" max="20" value="2" step="1" aria-label="Pixels to remove from each tile edge" style="width: 4em;">
      <span class="trim-hint">Remove grid lines from each tile (set before Cut; 4–6 px often needed for ChatGPT grids)</span>
    </p>
  </section>
  <p class="error" id="error" aria-live="polite"></p>

  <section class="grid-editor" id="grid-editor" aria-label="Adjust cutting lines">
    <h2>Adjust cutting lines</h2>
    <p class="intro" style="margin-bottom: 0.75rem;">Drag the <strong>blue</strong> lines to cut off the outer border; drag the <strong>red</strong> lines to match the inner grid. Zoom in for precise placement. Then click Cut.</p>
    <div class="grid-editor-toolbar">
      <label>Zoom: <span id="zoom-value">1</span>×</label>
      <input type="range" id="zoom" min="0.5" max="2.5" step="0.1" value="1" aria-label="Zoom">
      <label>Line thickness: <span id="line-thickness-value">2</span>px</label>
      <input type="range" id="line-thickness" min="1" max="5" step="1" value="2" aria-label="Cutting line thickness">
    </div>
    <div class="grid-preview-scroll" id="grid-preview-scroll">
      <div class="grid-preview-wrapper" id="grid-preview-wrapper">
        <img id="grid-image" alt="Your grid image" style="max-width: 100%; height: auto;">
        <canvas id="grid-overlay" class="grid-overlay" aria-hidden="true"></canvas>
      </div>
    </div>
    <div class="grid-editor-buttons">
      <span class="trim-inline">
        <label for="trim-pixels-inline">Trim:</label>
        <input type="number" id="trim-pixels-inline" min="0" max="20" value="2" step="1" style="width: 3.5em;" title="Pixels to remove from each side of every tile (reduces grid lines)">
      </span>
      <button type="button" class="btn btn-secondary" id="reset-lines">Reset lines</button>
      <button type="button" class="btn" id="cut-btn">Cut and create 16 images</button>
    </div>
  </section>

  <section class="output" id="output" aria-label="Split result">
    <h2>Preview: 16 tiles</h2>
    <div class="preview-grid" id="preview-grid"></div>
    <button type="button" class="btn" id="download-zip">Download all as ZIP</button>
    <p class="download-hint">If Windows blocks the file, right-click it → Properties → check Unblock → OK.</p>
  </section>

  <script>
    (function () {
      var dropZone = document.getElementById('drop-zone');
      var fileInput = document.getElementById('file-input');
      var errorEl = document.getElementById('error');
      var outputEl = document.getElementById('output');
      var previewGrid = document.getElementById('preview-grid');
      var downloadBtn = document.getElementById('download-zip');

      var tileBlobs = [];
      var objectUrl = null;
      var currentImage = null;
      var xBounds = [];
      var yBounds = [];
      var drag = { active: false, axis: null, index: null };
      var gridImg = document.getElementById('grid-image');
      var gridOverlay = document.getElementById('grid-overlay');
      var gridWrapper = document.getElementById('grid-preview-wrapper');
      var gridScroll = document.getElementById('grid-preview-scroll');
      var gridEditor = document.getElementById('grid-editor');
      var baseWidth = 0;
      var baseHeight = 0;

      function getTrimPixels() {
        var el = document.getElementById('trim-pixels-inline') || document.getElementById('trim-pixels');
        return el ? Math.max(0, parseInt(el.value, 10) || 0) : 0;
      }
      function getZoom() {
        var el = document.getElementById('zoom');
        return el ? parseFloat(el.value) || 1 : 1;
      }
      function getLineThickness() {
        var el = document.getElementById('line-thickness');
        return el ? Math.max(1, parseInt(el.value, 10) || 2) : 2;
      }

      function clearError() {
        errorEl.textContent = '';
      }
      function showError(msg) {
        errorEl.textContent = msg;
      }

      function initBounds(w, h) {
        xBounds = [0, w / 4, w / 2, (3 * w) / 4, w];
        yBounds = [0, h / 4, h / 2, (3 * h) / 4, h];
      }

      function drawOverlay() {
        if (!currentImage || !gridOverlay) return;
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var cw = gridOverlay.width;
        var ch = gridOverlay.height;
        if (cw <= 0 || ch <= 0) return;
        var ctx = gridOverlay.getContext('2d');
        ctx.clearRect(0, 0, cw, ch);
        // Draw in image pixel coordinates (canvas buffer = image size), so zoom only scales the view
        var displayW = gridOverlay.clientWidth || cw;
        var thickness = Math.max(1, Math.round(getLineThickness() * (cw / displayW)));
        // Outer cut lines (blue)
        ctx.strokeStyle = 'rgba(50, 100, 220, 0.95)';
        ctx.lineWidth = Math.max(2, thickness);
        ctx.beginPath();
        ctx.moveTo(xBounds[0], 0);
        ctx.lineTo(xBounds[0], ch);
        ctx.moveTo(xBounds[4], 0);
        ctx.lineTo(xBounds[4], ch);
        ctx.moveTo(0, yBounds[0]);
        ctx.lineTo(cw, yBounds[0]);
        ctx.moveTo(0, yBounds[4]);
        ctx.lineTo(cw, yBounds[4]);
        ctx.stroke();
        // Inner grid lines (red)
        ctx.strokeStyle = 'rgba(220, 50, 50, 0.9)';
        ctx.lineWidth = thickness;
        ctx.beginPath();
        for (var i = 1; i <= 3; i++) {
          ctx.moveTo(xBounds[i], 0);
          ctx.lineTo(xBounds[i], ch);
        }
        for (var j = 1; j <= 3; j++) {
          ctx.moveTo(0, yBounds[j]);
          ctx.lineTo(cw, yBounds[j]);
        }
        ctx.stroke();
      }

      function hitLine(imgX, imgY) {
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var hitPx = Math.max(8, w / 80);
        for (var i = 0; i <= 4; i++) {
          if (Math.abs(imgX - xBounds[i]) <= hitPx) return { axis: 'v', index: i };
        }
        for (var j = 0; j <= 4; j++) {
          if (Math.abs(imgY - yBounds[j]) <= hitPx) return { axis: 'h', index: j };
        }
        return null;
      }

      function setupGridEditor(img) {
        currentImage = img;
        var w = img.naturalWidth;
        var h = img.naturalHeight;
        initBounds(w, h);
        gridImg.src = img.src;
        function sizeOverlay() {
          baseWidth = gridImg.offsetWidth;
          baseHeight = gridImg.offsetHeight;
          if (!baseWidth || !baseHeight) return;
          var w = currentImage.naturalWidth;
          var h = currentImage.naturalHeight;
          gridOverlay.width = w;
          gridOverlay.height = h;
          gridOverlay.style.width = baseWidth + 'px';
          gridOverlay.style.height = baseHeight + 'px';
          gridWrapper.style.width = baseWidth + 'px';
          gridWrapper.style.height = baseHeight + 'px';
          applyZoom();
          drawOverlay();
        }
        gridImg.onload = sizeOverlay;
        gridEditor.classList.add('visible');
        outputEl.classList.remove('visible');
        if (gridImg.complete) setTimeout(sizeOverlay, 0);
      }

      function applyZoom() {
        var zoom = getZoom();
        document.getElementById('zoom-value').textContent = zoom.toFixed(1);
        if (baseWidth && baseHeight) {
          gridWrapper.style.width = (baseWidth * zoom) + 'px';
          gridWrapper.style.height = (baseHeight * zoom) + 'px';
          gridWrapper.style.transform = 'scale(' + zoom + ')';
        }
      }

      function handleFile(file) {
        clearError();
        if (!file || !file.type.startsWith('image/')) {
          showError('Please drop or select an image file.');
          return;
        }
        var url = URL.createObjectURL(file);
        if (objectUrl) URL.revokeObjectURL(objectUrl);
        objectUrl = url;
        var img = new Image();
        img.onload = function () {
          setupGridEditor(img);
        };
        img.onerror = function () {
          showError('Could not load the image.');
        };
        img.src = url;
      }

      function runCut() {
        if (!currentImage || typeof gridSplit === 'undefined' || !gridSplit.splitGridCustom) {
          showError('Grid splitter not loaded.');
          return;
        }
        clearError();
        gridSplit.splitGridCustom(currentImage, xBounds, yBounds, { trimPixels: getTrimPixels() })
          .then(function (blobs) {
            if (blobs.length !== 16) {
              showError('Expected 16 tiles, got ' + blobs.length);
              return;
            }
            tileBlobs = blobs;
            previewGrid.innerHTML = '';
            blobs.forEach(function (blob) {
              var thumb = document.createElement('img');
              thumb.src = URL.createObjectURL(blob);
              thumb.alt = 'Tile preview';
              previewGrid.appendChild(thumb);
            });
            outputEl.classList.add('visible');
            downloadBtn.disabled = false;
          })
          .catch(function (err) {
            showError(err && err.message ? err.message : 'Failed to create tiles.');
          });
      }

      gridOverlay.addEventListener('mousedown', function (e) {
        var rect = gridOverlay.getBoundingClientRect();
        var imgX = (e.clientX - rect.left) / (rect.width || 1) * currentImage.naturalWidth;
        var imgY = (e.clientY - rect.top) / (rect.height || 1) * currentImage.naturalHeight;
        var hit = hitLine(imgX, imgY);
        if (hit) {
          e.preventDefault();
          drag.active = true;
          drag.axis = hit.axis;
          drag.index = hit.index;
        }
      });
      document.addEventListener('mousemove', function (e) {
        if (!drag.active || !currentImage) return;
        var rect = gridOverlay.getBoundingClientRect();
        var w = currentImage.naturalWidth;
        var h = currentImage.naturalHeight;
        var displayX = (e.clientX - rect.left) / (rect.width || 1) * w;
        var displayY = (e.clientY - rect.top) / (rect.height || 1) * h;
        var pt = {
          x: Math.max(0, Math.min(w, displayX)),
          y: Math.max(0, Math.min(h, displayY))
        };
        if (drag.axis === 'v') {
          var minX = drag.index > 0 ? xBounds[drag.index - 1] + 2 : 0;
          var maxX = drag.index < 4 ? xBounds[drag.index + 1] - 2 : w;
          xBounds[drag.index] = Math.max(minX, Math.min(maxX, pt.x));
        } else {
          var minY = drag.index > 0 ? yBounds[drag.index - 1] + 2 : 0;
          var maxY = drag.index < 4 ? yBounds[drag.index + 1] - 2 : h;
          yBounds[drag.index] = Math.max(minY, Math.min(maxY, pt.y));
        }
        drawOverlay();
      });
      document.addEventListener('mouseup', function () {
        drag.active = false;
        drag.axis = null;
        drag.index = null;
      });

      document.getElementById('zoom').addEventListener('input', function () {
        applyZoom();
      });
      document.getElementById('line-thickness').addEventListener('input', function () {
        document.getElementById('line-thickness-value').textContent = this.value;
        drawOverlay();
      });

      document.getElementById('reset-lines').addEventListener('click', function () {
        if (currentImage) {
          initBounds(currentImage.naturalWidth, currentImage.naturalHeight);
          drawOverlay();
        }
      });
      document.getElementById('cut-btn').addEventListener('click', runCut);
      var trimMain = document.getElementById('trim-pixels');
      var trimInline = document.getElementById('trim-pixels-inline');
      if (trimMain && trimInline) {
        trimMain.addEventListener('input', function () { trimInline.value = trimMain.value; });
        trimInline.addEventListener('input', function () { trimMain.value = trimInline.value; });
      }

      dropZone.addEventListener('click', function (e) {
        if (e.target.id !== 'browse-btn') fileInput.click();
      });
      document.getElementById('browse-btn').addEventListener('click', function (e) {
        e.preventDefault();
        e.stopPropagation();
        fileInput.click();
      });
      dropZone.addEventListener('dragover', function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.dataTransfer.dropEffect = 'copy';
        dropZone.classList.add('dragover');
      });
      dropZone.addEventListener('dragleave', function (e) {
        e.preventDefault();
        e.stopPropagation();
        if (!dropZone.contains(e.relatedTarget)) dropZone.classList.remove('dragover');
      });
      dropZone.addEventListener('drop', function (e) {
        e.preventDefault();
        e.stopPropagation();
        dropZone.classList.remove('dragover');
        var file = e.dataTransfer.files && e.dataTransfer.files[0];
        handleFile(file);
      });
      fileInput.addEventListener('change', function () {
        handleFile(fileInput.files[0]);
      });

      downloadBtn.addEventListener('click', function () {
        if (tileBlobs.length !== 16) return;
        downloadBtn.disabled = true;
        var zip = new JSZip();
        var index = 0;
        for (var r = 0; r < 4; r++) {
          for (var c = 0; c < 4; c++) {
            var name = 'tile_' + r + '_' + c + '.png';
            zip.file(name, tileBlobs[index], { binary: true });
            index++;
          }
        }
        zip.generateAsync({ type: 'blob' }).then(function (blob) {
          var a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'grid-tiles.zip';
          a.click();
          URL.revokeObjectURL(a.href);
          downloadBtn.disabled = false;
        }).catch(function () {
          showError('Failed to create ZIP.');
          downloadBtn.disabled = false;
        });
      });
    })();
  </script>
</body>
</html>
